# -*- coding: utf-8 -*-
"""Lane Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lb5PT1WegsPDELqrIOa2WjBXEnbz4hDw

### Import necessary libraries
"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
from moviepy.editor import *
from IPython.display import HTML

from google.colab import drive
drive.mount('/content/drive')

"""### Read Images"""

imgInventory = "/content/drive/MyDrive/CSE428 Project/test_images/test/"
imgFiles = os.listdir(imgInventory) #keeps the names of the files
imgCatalogue = [] 
                  
for i in range(0, len(imgFiles)):
    imgCatalogue.append(plt.imread(imgInventory + imgFiles[i]))

"""### Display Images"""

# DISPLAY FUNCTION
def show_img(images, cmap=None):
    plt.figure(figsize=(35,35))
    for i, img in enumerate(images):
        plt.autoscale(tight=True)
        plt.subplot(1,2,i+1)
        plt.imshow(img, cmap)
        plt.axis("off")
    
    plt.show()

show_img(imgCatalogue)

def yw_filter(img):
    #convert to HLS to mask based on HLS
    imgHSL = cv2.cvtColor(img, cv2.COLOR_RGB2HLS) 
    yellowLow = np.array([10,0,90])
    yellowHigh = np.array([50,255,255])
    whiteLow = np.array([0,100,0])
    whiteHigh = np.array([255,255,255])
    yellowFilter = cv2.inRange(imgHSL, yellowLow, yellowHigh)
    whiteFilter = cv2.inRange(imgHSL, whiteLow, whiteHigh)
    mask = cv2.bitwise_or(whiteFilter, yellowFilter)
    target = cv2.bitwise_and(img, img, mask = mask)
    return target

filtered_img = list(map(yw_filter, imgCatalogue))
show_img(filtered_img, cmap='gray') #Displaying the filtered img

# Finding the region of interest
def roi(img):
    w = int(img.shape[1]) #Width of the image
    h = int(img.shape[0]) #Height of the image
    #print(img.shape)
    black_img = np.zeros_like(img) #creating a black image with the same dimension as main image
    white_pixels = (255,255,255)
    shape = np.array([[int(0), int(h)], [int(w), int(h)], [int(w*0.55), int(h*0.6)], [int(w*0.45), int(h*0.6)]]) #these are the 4 coordinates of our region of interest
    #creates a polygon with the white pixels
    cv2.fillPoly(black_img, np.int32([shape]), white_pixels) #we are setting the pixel values to 255 inside our region of interest which we defined through the 4 coordinates
    target_image = cv2.bitwise_and(img, black_img) #taking all the common pixel values between main image and masked image
    return target_image

roi_img = list(map(roi, filtered_img))
show_img(roi_img)

def canny(img):
    return cv2.Canny(cv2.cvtColor(img, cv2.COLOR_RGB2GRAY), 30, 80) # 30 and 80 are the 2 thresholds for hysteresis procedure

canny_img = list(map(canny, roi_img))
show_img(canny_img, cmap='gray')

#Hough Line Detection

rightSlope, leftSlope, rightIntercept, leftIntercept = [],[],[],[]

def draw_lines(img, lines, thickness=5):
    global rightSlope, leftSlope, rightIntercept, leftIntercept
    
    rightBoundary = [211, 3, 252] #purple color for right side of the lane's boundary
    leftBoundary = [255, 0, 0]  #orange color for left side of the lane's boundary
    
    '''
    This is used to eliminate outlying lines that may have an impact on the average and 
    then By solving for c in y = mx + c, we can compute the points where the filtered lines intercepted y-axis
    using the slope we determined beforehand. 
    '''
    #count = 0;
    if lines is not None:
        for line in lines:
            #count = count + 1
            for x1,y1,x2,y2 in line:
                slope = (y1-y2)/(x1-x2)
                if slope > 0.3 and x1 > 500: #for yellow line of the lane
                    yintercept = y2 - (slope*x2)
                    rightSlope.append(slope)
                    rightIntercept.append(yintercept)
                    #else: None
                elif slope < -0.3 and x1 < 600: #for white line of the lane
                    yintercept = y2 - (slope*x2)
                    leftSlope.append(slope)
                    leftIntercept.append(yintercept)
        #print("count", count)
    else:
      pass
    #We use slicing operators and np.mean() to find the averages of the 30 previous frames
    #This makes the lines more stable, and less likely to shift rapidly
    leftavgSlope = np.mean(leftSlope[-30:])
    leftavgIntercept = np.mean(leftIntercept[-30:])
    rightavgSlope = np.mean(rightSlope[-40:])
    rightavgIntercept = np.mean(rightIntercept[-40:])
    #Here we plot the lines and the shape of the lane using the average slope and intercepts
    try:
        left_line_x1 = int((0.65*img.shape[0] - leftavgIntercept)/leftavgSlope)
        left_line_x2 = int((img.shape[0] - leftavgIntercept)/leftavgSlope)
        right_line_x1 = int((0.65*img.shape[0] - rightavgIntercept)/rightavgSlope)
        right_line_x2 = int((img.shape[0] - rightavgIntercept)/rightavgSlope)
        pts = np.array([[left_line_x1, int(0.65*img.shape[0])],[left_line_x2, int(img.shape[0])],[right_line_x2, int(img.shape[0])],[right_line_x1, int(0.65*img.shape[0])]], np.int32)
        pts = pts.reshape((-1,1,2))
        cv2.fillPoly(img,[pts],(0, 107, 29)) #color of the detected lane 
        cv2.line(img, (left_line_x1, int(0.65*img.shape[0])), (left_line_x2, int(img.shape[0])), leftBoundary, 10)
        cv2.line(img, (right_line_x1, int(0.65*img.shape[0])), (right_line_x2, int(img.shape[0])), rightBoundary, 10)
    except Error:
        pass

def hough_lines(img, rho, theta, threshold, min_line_len, max_line_gap):
    lines = cv2.HoughLinesP(img, rho, theta, threshold, np.array([]), minLineLength=min_line_len, maxLineGap=max_line_gap) 
    #rho: The resolution parameter in pixels
    #theta: The resolution of the parameter in radians
    #threshold: The minimum number of intersecting points to detect a line
    #minLineLength - Line segments shorter than this are rejected
    #maxLineGap - Maximum allowed gap between line segments to treat them as single line
    line_img = np.zeros((img.shape[0], img.shape[1], 3), dtype=np.uint8)
    draw_lines(line_img, lines)
    return line_img

def linedetect(img):
    return hough_lines(img, 1, np.pi/180, 10, 20, 100)

hough_img = list(map(linedetect, canny_img))
show_img(hough_img)

def weightSum(input_set):
    img = list(input_set)
    return cv2.addWeighted(img[0], 1, img[1], 0.8, 0)
result_img = list(map(weightSum, zip(hough_img, imgCatalogue)))
show_img(result_img)

pip install moviepy

def processImage(image):
    interest = roi(image)
    filtering = yw_filter(interest)
    canny = cv2.Canny(cv2.cvtColor(filtering, cv2.COLOR_RGB2GRAY), 50, 120)
    myline = hough_lines(canny, 1, np.pi/180, 10, 20, 5)
    weighted_img = cv2.addWeighted(myline, 1, image, 0.8, 0)
    return weighted_img

# Commented out IPython magic to ensure Python compatibility.
output1 = "/content/drive/MyDrive/CSE428 Project/video_output/Lane4.mp4"
clip = VideoFileClip("/content/drive/MyDrive/CSE428 Project/test_videos/test/Lane1.mp4")
pclip1 = clip.fl_image(processImage) #NOTE: this function expects color images!!
# %time pclip1.write_videofile(output1, audio=False)
